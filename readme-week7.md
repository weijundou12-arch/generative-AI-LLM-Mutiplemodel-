Week 7（面试满分答案版）
章节重点 1：Agent 是什么（和 RAG/LLM 的边界）

面试考点 1：什么是 Agent？和“普通 LLM 调用”有什么本质区别？
满分简答：Agent 是“模型作为决策器”，能根据目标 规划步骤、调用工具、读写外部状态，并在多轮交互中逐步完成任务。普通 LLM 只是一次生成文本；Agent 能把任务分解为多步并与外部系统协作（检索/计算/数据库/文件/接口）。

面试考点 2：为什么企业需要 Agent，而不仅是 RAG？
满分简答：RAG 解决“拿到知识”，Agent 解决“把知识用起来”：例如从文档抽数→计算→生成结构化报告→写入系统→触发通知。企业需求往往是工作流自动化，不只是回答问题。

章节重点 2：ReAct（Reason + Act）核心机制

面试考点 3：ReAct 是什么？为什么有效？
满分简答：ReAct 让模型交替输出 思考（Reason） 与 行动（Act）：先决定下一步调用哪个工具、用什么参数；拿到工具结果（Observation）后再继续推理。它有效是因为把“推理”和“外部执行”解耦，让模型能用真实工具结果纠错，降低幻觉。

面试考点 4：ReAct 的基本循环长什么样？
满分简答：Thought → Action(tool,args) → Observation(result) → Thought ... → Final。其中最关键是：工具输出必须回灌给模型作为证据，最后答案必须基于 Observations。

面试考点 5：为什么企业 Agent 需要“可控的输出格式”？
满分简答：因为要稳定解析并触发工具调用。生产中通常强制模型输出 JSON/固定语法（比如 Action: tool_name {json}），否则容易因格式漂移导致系统崩溃。

章节重点 3：工具（Tools）与函数调用（Function Calling）

面试考点 6：工具调用在工程上要解决哪三件事？
满分简答：
1）工具规范化（name/description/schema）
2）安全控制（allowlist、参数校验、超时、限流）
3）可观测性（每次调用的输入/输出/耗时/错误都要记录）

面试考点 7：为什么要给工具定义 schema（参数 JSON 结构）？
满分简答：schema 能把自然语言约束为可验证的结构化输入，降低“模型乱填参数”导致的错误；也便于前后端一致性、自动测试和版本管理。

章节重点 4：规划（Planning）与调度（Orchestration）

面试考点 8：Plan-and-Execute 和 ReAct 有什么区别？
满分简答：Plan-and-Execute 先生成完整计划再执行，适合任务结构清晰但计划可能过时；ReAct 边做边改，适合信息不完整、需要根据工具结果动态调整的任务。企业常用混合：先粗计划，再 ReAct 执行。

面试考点 9：多工具调度时，最常见的失败原因是什么？
满分简答：工具选错/参数错/结果噪声大/循环不停止。解决靠：工具路由规则、重试与回退策略、最大步数、以及“停止条件”（已满足目标/证据不足则拒答）。

章节重点 5：记忆（Memory）与状态（State）

面试考点 10：Agent 的记忆分哪几类？
满分简答：

短期记忆：本轮对话上下文、scratchpad

长期记忆：用户偏好、历史事实（需可检索/可更新）

工作记忆：任务中间产物（抽取的数据、草稿、证据列表）

面试考点 11：为什么要把“证据（evidence）”单独存？
满分简答：因为最终答案需要可追溯引用，证据应结构化保存（doc_id/chunk_id/片段），便于审计和复用，也便于做 groundedness 评测。

章节重点 6：可靠性（Reliability）与工程防护

面试考点 12：企业 Agent 必须有哪些“护栏”（guardrails）？
满分简答：至少包括：工具白名单、参数 schema 校验、超时/重试、最大步数、输出约束、敏感操作二次确认（如写库/发邮件），以及“证据不足则拒答”。

面试考点 13：如何避免 Agent 无限循环？
满分简答：设置 max_steps，并设计明确的 stop 条件（例如已拿到关键证据并完成计算/报告），以及“进展检测”（连续两步无新增信息则停止并给出失败原因）。

章节重点 7：可观测性（Observability）与评测

面试考点 14：上线后怎么定位 Agent 性能问题？看什么日志？
满分简答：必须有 trace_id；记录每步：模型输出、选用工具、参数、工具耗时、工具结果摘要、最终答案与引用。关键指标：成功率、平均步数、工具失败率、延迟、引用准确率/拒答率。

面试考点 15：Agent 怎么做离线评测？
满分简答：用任务集（问题→期望证据/答案），评测：任务完成率、工具调用正确率、引用命中率、延迟与成本。对每个失败样本做 error taxonomy（检索失败/路由失败/生成失败）。
